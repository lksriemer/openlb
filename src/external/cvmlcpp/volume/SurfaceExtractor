/***************************************************************************
 *   Copyright (C) 2007 by BEEKHOF, Fokko                                  *
 *   fpbeekhof@gmail.com                                                   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifndef CVMLCPP_SURFACE_EXTRACTOR
#define CVMLCPP_SURFACE_EXTRACTOR 1

#include <cvmlcpp/math/Euclid>
#include <cvmlcpp/base/Meta>
#include <cvmlcpp/volume/Geometry>

#include <cvmlcpp/volume/VolumeHelpers.h>

#ifdef _OPENMP
#include <omp.h>
#endif

namespace cvmlcpp
{

extern unsigned	 _pairTable[][2];
extern unsigned	 _edgeTable[];
extern char _triTable[][16];

/**
 * Linearly interpolate the position where an isosurface cuts
 * an edge between two vertices, each with their own scalar value
 */
template <typename voxel_type, typename Tg>
inline void _VertexInterp(const double &isolevel,
		const iPoint3D &p1, const iPoint3D &p2,
		const voxel_type &valp1, const voxel_type &valp2,
		Point3D<Tg> &pOut)
{
	assert ( ( (valp1 <= isolevel) && (isolevel <= valp2) ) ||
		( (valp2 <= isolevel) && (isolevel <= valp1) ) );
	assert(std::abs(valp2 - valp1) > 0.0);

	Tg mu = (isolevel - double(valp1)) / double(valp2 - valp1);

	if (! ((mu >= 0.0) && (mu <= 1.0)) )
		mu = 0.5;

	pOut = p1.convert<Tg>() + (p2 - p1).convert<Tg>() * mu;
}

template <
    template <typename Tm, std::size_t D, typename Aux> class Matrix_t,
    typename Ti, typename A>
class MatrixSurfaceAdaptor_
{
	public:
		typedef Ti value_type;
		MatrixSurfaceAdaptor_(const Matrix_t<Ti, 3u, A> &matrix) : matrix_(matrix) { }
		Ti operator()(std::size_t x, std::size_t y, std::size_t z) const
		{ return matrix_[x][y][z]; }

		template <typename It>
		void dims(It dims_) const
		{
			typedef array_traits<Matrix_t, Ti, 3u, A> MTraits;
			std::copy(MTraits::shape(matrix_), MTraits::shape(matrix_)+3, dims_);
		}

	private:
		const Matrix_t<Ti, 3u, A> &matrix_;
};
/*
template <typename Ti>
class OctreeSurfaceAdaptor_
{
	public:
		typedef Ti value_type;
		OctreeSurfaceAdaptor_(const DTree<Ti, 3u> &octree) : octree_(octree) { }
		Ti operator()(std::size_t x, std::size_t y, std::size_t z) const
		{ return ; }

		template <typename It>
		void dims(It dims_) const
		{
		}

	private:
		const DTree<Ti, 3u> &octree_;
};
*/
template <class Adapter, typename Tg>
void extractSurfaceFromAdapter(const Adapter &adapter,
			   Geometry<Tg> &geometry, const double isolevel)
{
// Based on code from:
// http://astronomy.swin.edu.au/~pbourke/modelling/polygonise/

	typedef typename Adapter::value_type		voxel_type;
	typedef typename Geometry<Tg>::facet_type	facet_type;
	typedef typename Geometry<Tg>::vector_type	vector_type;

	std::size_t dim[3];
	adapter.dims(dim);
	
	geometry.clear();
	if (dim[X] < 1 || dim[Y] < 1 || dim[Z] < 1 )
		return;

	std::vector<std::vector<Point3D<typename Geometry<Tg>::value_type> > > points(dim[X]-1);
	std::vector<std::vector<vector_type> > normals(dim[X]-1);

#ifdef _OPENMP
	const std::vector<Adapter> adapters(omp_get_max_threads(), adapter);
#else
	const Adapter matrix = adapter;
#endif

	#ifdef _OPENMP
	#pragma omp parallel for
	#endif
	for (int x = 0u; x < int(dim[X]-1); ++x)
	{
#ifdef _OPENMP
		const Adapter &matrix = adapters[omp_get_thread_num()];
#endif
		voxel_type val[8];
	
		for (std::size_t y = 0u; y < dim[Y] - 1u; ++y)
		{
			// Boundary conditions
			val[2] = matrix(x+1,   y, 0);
			val[3] = matrix(  x,   y, 0);
			val[6] = matrix(x+1, y+1, 0);
			val[7] = matrix(  x, y+1, 0);
		
			for (std::size_t z = 0u; z < dim[Z] - 1u; ++z)
			{
				val[0] = val[3];
				val[3] = matrix(  x,   y, z+1);
				val[1] = val[2];
				val[2] = matrix(x+1,   y, z+1);
				val[4] = val[7];
				val[7] = matrix(  x, y+1, z+1);
				val[5] = val[6];
				val[6] = matrix(x+1, y+1, z+1);
		/*		val[0] = matrix(    x,    y,    z);
				val[1] = matrix(x + 1,    y,    z);
				val[2] = matrix(x + 1,    y,z + 1);
				val[3] = matrix(    x,    y,z + 1);
				val[4] = matrix(    x,y + 1,    z);
				val[5] = matrix(x + 1,y + 1,    z);
				val[6] = matrix(x + 1,y + 1,z + 1);
				val[7] = matrix(    x,y + 1,z + 1);
		*/
				// Determine the index into the edge table which
				// tells us which vertices are inside of the
				// surface
				std::size_t cubeIndex = 0u;
				for (unsigned i = 0u; i < 8u; ++i)
					if (val[i] < isolevel)
						cubeIndex |= (1u << i);
		
				// Cube is entirely in/out of the surface
				if (_edgeTable[cubeIndex] == 0u)
					continue;
		
				// Prepare points of cube relative to point in matrix.
				static
				const typename iPoint3D::value_type offset [8] [3] = {
					{0, 0, 0}, {1, 0, 0}, {1, 0, 1}, {0, 0, 1},
					{0, 1, 0}, {1, 1, 0}, {1, 1, 1}, {0, 1, 1} };
		
				const iPoint3D here(std::size_t(x), y, z);
				iPoint3D pts[8];
				for (unsigned i = 0; i < 8; ++i)
					pts[i] = here.jmp(offset[i][X], offset[i][Y], offset[i][Z]);
		
				// Find the vertices where the surface intersects the cube
				typename Geometry<Tg>::point_type vertlist[12];
				for (std::size_t i = 0; i < 12u; ++i)
					if (_edgeTable[cubeIndex] & (1u << i))
						_VertexInterp(isolevel,
							pts[_pairTable[i][0]],
							pts[_pairTable[i][1]],
							val[_pairTable[i][0]],
							val[_pairTable[i][1]], vertlist[i]);
		
				// Prepare points and facets
				for (unsigned i = 0u; _triTable[cubeIndex][i] != -1; i += 3u)
				{
					// Determine points
					for (std::size_t j = 0u; j < 3u; ++j)
						points[x].push_back(vertlist[int(_triTable[cubeIndex][i+j])]);
		
					// Compute normal
					const std::size_t a  = points[x].size() - 3;
					const std::size_t b  = points[x].size() - 2;
					const std::size_t c  = points[x].size() - 1;
					const vector_type ab = points[x][b] - points[x][a];
					const vector_type ac = points[x][c] - points[x][a];
					vector_type normal   = crossProduct(ab, ac);
					normal /= modulus(normal);
		
					// check normal orientation
					const vector_type center =
						(points[x][a]+points[x][b]+points[x][c])/Tg(3.0);
					const vector_type loc = normal + center;
		
					const std::size_t xx = clamp(round_cast<std::size_t>(loc[X]),
								 std::size_t(0), dim[X]-1);
					const std::size_t yy = clamp(round_cast<std::size_t>(loc[Y]),
								 std::size_t(0), dim[Y]-1);
					const std::size_t zz = clamp(round_cast<std::size_t>(loc[Z]),
								 std::size_t(0), dim[Z]-1);
		
					if (matrix(xx, yy, zz) > isolevel)
					{
						normal *= -1.0;
						// reverse order of points
						using std::swap;
						swap(points[x][b], points[x][c]);
					}
		
					normals[x].push_back(normal);
				}
			}
		}
	}
	
	//
	std::vector<std::size_t> cumSizes(points.size()+1);
	cumSizes[0] = 0;
	for (std::size_t i = 1; i < cumSizes.size(); ++i)
		cumSizes[i] = cumSizes[i-1] + points[i-1].size();

	typedef IndexPoint<typename Geometry<Tg>::value_type> IdxPoint;
	std::vector<IdxPoint> idxPoints(cumSizes.back());
#ifdef _OPENMP
#pragma omp parallel for
#endif
	for (int x = 0u; x < int(points.size()); ++x)
	{
		std::size_t pIndex = cumSizes[x];
		for (std::size_t i = 0; i < points[x].size(); ++i, ++pIndex)
			idxPoints[pIndex] = (IdxPoint( (pIndex),  points[x][i] ));
	}

	//
	cumSizes.resize(normals.size()+1);
	cumSizes[0] = 0;
	for (std::size_t i = 1; i < cumSizes.size(); ++i)
		cumSizes[i] = cumSizes[i-1] + normals[i-1].size();
	std::vector<vector_type> allNormals(cumSizes.back());
#ifdef _OPENMP
#pragma omp parallel for
#endif
	for (int x = 0u; x < int(normals.size()); ++x)
	{
		std::size_t pIndex = cumSizes[x];
		for (std::size_t i = 0; i < normals[x].size(); ++i, ++pIndex)
			allNormals[pIndex] = normals[x][i];
	}

	_constructGeometry(geometry, idxPoints, allNormals);
}

template <
    template <typename Tm, std::size_t D, typename Aux> class Matrix_t,
    typename Ti, typename A, typename Tg>
void extractSurface(const Matrix_t<Ti, 3u, A> &matrix,
		    Geometry<Tg> &geometry, const double isolevel = 0.5)
{
	extractSurfaceFromAdapter(MatrixSurfaceAdaptor_<Matrix_t, Ti, A>((matrix)), geometry, isolevel);
}

/*
template <typename Ti, typename Tg>
void extractSurface(const DTree<Ti, 3u> &octree,
			   Geometry<Tg> &geometry, const double isolevel = 0.5)
{
	extractSurface_(OctreeSurfaceAdaptor_((octree)), geometry, isolevel);
}
*/

} // namespace

#endif
